<!DOCTYPE html>
<html>
<head>
    <title>SVG Drag, Zoom, and Rotate Example</title>
</head>
<body>

<svg id="h_svg" viewBox="0 0 800 1200" width="800" height="1200">
    <g id="s_gtop">
        <!-- Rectangle -->
        <rect x="180" y="130" width="40" height="40" fill="red" />
    </g>
</svg>
<script>
((svg, gtop) => {
    const state = { dragging: false, startX: 0, startY: 0, rotation: 0 };
    const viewBox = svg.viewBox.baseVal;
    let transform = { x: 0, y: 0, scale: 1, rotate: 0, centerX: viewBox.width/2, centerY: viewBox.height/2 };

    function updateTransform() {
        gtop.setAttribute("transform", `translate(${transform.x},${transform.y}) scale(${transform.scale}) rotate(${transform.rotate},${transform.centerX},${transform.centerY})`);
    }

    function calculateMidPoint(touches) {
        const x = (touches[0].clientX + touches[1].clientX) / 2;
        const y = (touches[0].clientY + touches[1].clientY) / 2;
        return { x, y };
    }

    // Gesture events for Safari
    let initialScale = 1;
    let initialRotation = 0;
    svg.addEventListener('gesturestart', e => {
        e.preventDefault();
        initialScale = transform.scale;
        initialRotation = transform.rotate;

        if (e.touches.length === 2) {
            const midPoint = calculateMidPoint(e.touches);

            // 現在のスケールと移動量を考慮して中心点を調整
            transform.centerX = (midPoint.x - transform.x) / transform.scale;
            transform.centerY = (midPoint.y - transform.y) / transform.scale;
        }
    });

    svg.addEventListener('gesturechange', e => {
        e.preventDefault();
        transform.scale = initialScale * e.scale;
        transform.rotate = initialRotation + e.rotation;
        updateTransform();
    });

    svg.addEventListener('gestureend', e => {
        e.preventDefault();
    });

    // Touch events for drag
    svg.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            state.dragging = true;
            state.startX = touch.clientX;
            state.startY = touch.clientY;
        } else if (e.touches.length === 2) {
            const midPoint = calculateMidPoint(e.touches);

            // 現在のスケールと移動量を考慮して中心点を調整
            transform.centerX = (midPoint.x - transform.x) / transform.scale;
            transform.centerY = (midPoint.y - transform.y) / transform.scale;
        }
    });

    svg.addEventListener('touchmove', e => {
        e.preventDefault();
        if (state.dragging && e.touches.length === 1) {
            const touch = e.touches[0];
            transform.x += touch.clientX - state.startX;
            transform.y += touch.clientY - state.startY;
            state.startX = touch.clientX;
            state.startY = touch.clientY;
            updateTransform();
        } else if (e.touches.length === 2) {
            const midPoint = calculateMidPoint(e.touches);
            transform.centerX = (midPoint.x - transform.x) / transform.scale;
            transform.centerY = (midPoint.y - transform.y) / transform.scale;
            // ここで拡大と回転の処理を行う
        }
    });

    svg.addEventListener('touchend', () => {
        state.dragging = false;
    });

})(h_svg, s_gtop);
</script>
</body>
</html>

