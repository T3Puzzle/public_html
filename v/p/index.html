<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=600, user-scalable=no">
    <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/destyle.css@1.0.15/destyle.css"
/>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  </head>
  <body style="margin: 0px; padding: 0px; width: 100%; height: 100%;user-select: none;touch-action: none;-webkit-user-select: none;">
<script src="https://cdn.jsdelivr.net/npm/paper@0.12.17/dist/paper-full.min.js"></script>
  <style>
  .c_draw {
    width: 600px;
    height: 800px;
  }
</style>
<div style="position: relative;">
  <canvas class="c_draw" id="h_canvas" style="position:absolute; left:0px;top:0px;z-index:0;"></canvas>
  <p id="h_warn" style="position:absolute; left:0px;top:0px;z-index:200;">WARN:</p>
</div>

<script>
  if ('ontouchstart' in window) {
    const offset = {
      r: 0,
      s: 1
    };
    h_canvas.addEventListener('touchstart', e => {
      if (e.touches.length !== 2) return;
      e.preventDefault();
      const u = update(e, null);
      Object.assign(offset, {
        r: u.r,
        s: u.s
      });
      const m = h_canvas.getCTM();
      h_canvas.callback(true, 'touchstart', {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: u.cx,
        ty: u.cy
      }, {
        a: m.a,
        b: m.b,
        c: m.c,
        d: m.d,
        tx: m.tx - u.cx,
        ty: m.ty - u.cy
      });
    });
    h_canvas.addEventListener('touchmove', e => {
      if (e.touches.length !== 2) return;
      e.preventDefault();
      const u = update(e, offset);
      let tt = u.r * Math.PI / 180;
      let cc = Math.cos(tt);
      let ss = Math.sin(tt);
      let aa = u.s * cc;
      let bb = u.s * ss;
      h_canvas.callback(true, 'touchmove', {
        a: aa,
        b: bb,
        c: -bb,
        d: aa,
        tx: u.cx,
        ty: u.cy
      }, null);
    });
    h_canvas.addEventListener('touchend', e => {
      if (e.touches.length !== 2) return;
      e.preventDefault();
      const u = update(e, offset);
      Object.assign(offset, {
        r: 0,
        s: 1
      });
      const m = h_canvas.getCTM();
      h_canvas.callback(true, 'touchend', m, {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      });
    });

    function update(e, offset) {
      const cx = (e.touches[0].pageX + e.touches[1].pageX) / 2;
      const cy = (e.touches[0].pageY + e.touches[1].pageY) / 2;
      const o = {
        r: 0,
        s: 1
      };
      offset ? Object.assign(o, {
        r: offset.r,
        s: offset.s
      }) : null;
      const dx = e.touches[1].pageX - e.touches[0].pageX;
      const dy = e.touches[1].pageY - e.touches[0].pageY;
      const r = Math.atan2(dy, dx) * 180 / Math.PI - o.r;
      const s = Math.sqrt(dx * dx + dy * dy) / o.s;
      return {
        cx,
        cy,
        r,
        s
      };
    }
  }
</script>
    
    <script>

window.addEventListener("load", () => {
  paper.setup(h_canvas);
  const tool = new paper.Tool();
  const {g0,g1} = drawRectangle();
  let g = new paper.Matrix(1,0,0,1,0,0);
  h_canvas.getCTM = function () {
    let v=g1.viewMatrix;
    h_warn.textContent = 
      'v:'+v.a.toFixed(2)+' '+v.b.toFixed(2)+' '+v.tx.toFixed(2)+' '+v.ty.toFixed(2)+'\n'
    + 'g:'+g.a.toFixed(2)+' '+g.b.toFixed(2)+' '+g.tx.toFixed(2)+' '+g.ty.toFixed(2);
    return v;
  }
  h_canvas.callback = function (multi,type,m0,m1) {
      if (m0!==null) {
        g0.matrix = new paper.Matrix(m0.a,m0.b,m0.c,m0.d,m0.tx,m0.ty);
      }
      if (m1!==null) {
        g1.matrix = new paper.Matrix(m1.a,m1.b,m1.c,m1.d,m1.tx,m1.ty);
      }
      g = mult(g0,g1);
      //h_warn.textContent = 'update :'+type;
  }
});
function mult (m0,m1){
  let a0 = m0.a;
  let b0 = m0.b;
  let c0 = m0.c;
  let d0 = m0.d;
  let tx0 = m0.tx;
  let ty0 = m0.ty;
  let a1 = m1.a;
  let b1 = m1.b;
  let c1 = m1.c;
  let d1 = m1.d;
  let tx1 = m1.tx;
  let ty1 = m1.ty;
  return new paper.Matrix(
    a0*a1+b1*c0,
    a1*b0+b1*d0,
    a0*c1+c0*d1,
    b0*c1+d0*d1,
    a0*tx1+c0*ty1,
    b0*tx1+d0*ty1
  );
}
function drawRectangle() {
  
  let rect = new paper.Path.Rectangle({
    point: [100,100],
    size: [200,100],
    fillColor: "red"
  });
  rect.onClick = function () {
    h_warn.textContent = (111);
  }
  let g1 = new paper.Group({
    children: [rect],
    applyMatrix: false
  });
  let g0 = new paper.Group({
    children: [g1],
    applyMatrix: false
  });  
  return {g0,g1};
}
    </script>
  </body>
</html>
