
<!doctype html>
<html>
<head>
 <meta charset="utf-8">
 <base href="https://soma-arc.net/SchottkyV3/">
</head>
<body>
<div style="display: flex;
    justify-content: flex-end;position:sticky;top:0;">
<div style="position:absolute;">
<form>
<input size="50" value="https://soma-arc.net/SchottkyV3/" onchange="
 localStorage.setItem('base_href',this.value);
 document.querySelector('html >  head > base').setAttribute('href',this.value); 
">
<script>
let base_href = localStorage.getItem('base_href');
if (base_href && /^https*:\/\//.test(base_href)) {
  document.currentScript.closest('form').querySelector('input').value = base_href;
}
</script>
</form>
<svg width="400px" height="400px" style="border:solid 1px #404040;">
  <defs>
    <marker id="endarrow" markerWidth="3" markerHeight="7" 
    refX="3" refY="2" orient="auto">
      <polygon fill="blue" points="0 0, 3 2, 0 4" />
    </marker>
    <marker id="startarrow" markerWidth="3" markerHeight="7" 
    refX="0" refY="2" orient="auto">
      <polygon fill="blue" points="3 0, 3 4, 0 2" />
    </marker>
    <marker id="purpleendarrow" markerWidth="3" markerHeight="7" 
    refX="3" refY="2" orient="auto">
      <polygon fill="purple" points="0 0, 3 2, 0 4" />
    </marker>
    <marker id="purplestartarrow" markerWidth="3" markerHeight="7" 
    refX="0" refY="2" orient="auto">
      <polygon fill="purple" points="3 0, 3 4, 0 2" />
    </marker>
    <marker id="greenendarrow" markerWidth="3" markerHeight="7" 
    refX="3" refY="2" orient="auto">
      <polygon fill="green" points="0 0, 3 2, 0 4" />
    </marker>
    <marker id="greenstartarrow" markerWidth="3" markerHeight="7" 
    refX="0" refY="2" orient="auto">
      <polygon fill="green" points="3 0, 3 4, 0 2" />
    </marker>
    <marker id="orangeendarrow" markerWidth="3" markerHeight="7" 
    refX="3" refY="2" orient="auto">
      <polygon fill="orange" points="0 0, 3 2, 0 4" />
    </marker>
    <marker id="orangestartarrow" markerWidth="3" markerHeight="7" 
    refX="0" refY="2" orient="auto">
      <polygon fill="orange" points="3 0, 3 4, 0 2" />
    </marker>
  </defs>
<g class="base" transform="translate(200,200)scale(70,-70)">
<circle cx="0" cy="0" r="0.03">
</g>
</svg>
<br/>
<input name="title" size="50">
<p/>
<input name="param_x" type="range" min="0.8" max="2" value="1.2" step="0.1" onchange="updateMenu(this.value);svg();">
<button onclick="view()">view</button>
<button onclick="save()">save</button>
<p/>
<div style="display:flex;">
<div>
<select onchange="_detail(this.value)" style="width:150px;height:100px;" multiple="multiple">
</select>
</div>
<div id="detail_label" style="width:80px;margin-left:10px;">
</div>
<div id="detail_input" style="margin-left:10px;">
</div>
</div>
</div>
</div>
<div id="menu"></div>
<script>
function qs (wp) {
  return Object.values(wp)[0].map(g=>{ return Object.keys(g)[0]+'='+Object.values(g)[0].join(',')}).join('&')
}
function save () {
  const UPLOAD_URL = 'https://script.google.com/a/tessellation.jp/macros/s/AKfycbyMWzCt9bB-iNJ7bmGAYseMvVCojVr5Pe_NGe_K9QIrQcl4npJjg3pHIq3k_tbgtRZP/exec';
  let svgtag = document.querySelector("svg");
  let canvas = document.createElement("canvas");
  canvas.width = svgtag.width.baseVal.value;
  canvas.height = svgtag.height.baseVal.value;
  let ctx = canvas.getContext("2d");
  let image = new Image;
  image.addEventListener('load',()=>{
    ctx.drawImage( image,0,0);
    let body = { 
      filename: (new Date()).getTime()+'.png',
      type: 'image/png',
      content: canvas.toDataURL('image/png')
    };
    fetch_upload(UPLOAD_URL,body,(json)=>{
      let hash = '#FMS特別講義 #SchottkyLink';
      let url = 'https://drive.google.com/file/d/' + json.id + '/view';
      let array = [title, note, hash, url];
      let tweet = 'https://twitter.com/intent/tweet?text=' + encodeURIComponent(array.join('\n'));
      window.open("${tweet}");
    });
  });
  image.src = "data:image/svg+xml;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(svgtag)))); 

  function fetch_upload( url, body, successCallback, errorCallback) {
    fetch(url, {
        method: 'POST',
        body: body,
        mode: 'cors',
        redirect: 'follow',
      })
      .then(r => r.json())
      .then(j => {
        if (successCallback) {
          successCallback(j);
        }
      }).catch(e => {
        if (errorCallback) {
          errorCallback(e);
        }
      });
  }
}
function view() {
  let wpi = localStorage.getItem('wpi');
  if (wpi===null || wpi==="") {
    return;
  }
  wpi = parseInt(wpi,10);
  document.querySelector('a#a'+wpi).click();
}
function svg(wpi,title) {
  
  if (!wpi) {
    wpi = parseInt(localStorage.getItem('wpi'),10);
  }
  let wp = wps[wpi];
  document.querySelector('svg g.base').innerHTML = _svg(wp)+_origin();
  if (title) {
    document.querySelector('input[name=title]').value = title; 
  }
  document.querySelector('select').innerHTML = _opt(wp);
  localStorage.setItem('wpi',wpi);
}
function _input (labels,values) {
   document.querySelector('div#detail_label').innerHTML 
   = labels.map(label=>{
     return `<input size="12" disabled="disabled" value="${label}"><br/>`
   }).join('');

   let ret = [];
   values.forEach((value,i)=>{
     ret.push(`<input size="15" name="${labels[i]}" value="${value}"><br/>`);
   });
   document.querySelector('div#detail_input').innerHTML = ret.join('');
}
function _detail (kv) {
   let [key,valstr]=kv.split(':');
   let values = valstr.split(',');
   if (key==='HalfPlane[]') {
     _input(['pointX', 'pointY', 'normalX', 'normalY'], values);
   } else if (key==='CrossingInversions[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'degrees'], values);
   } else if (key==='GlideReflection[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'planeDistance'], values);
   } else if (key==='ParallelInversions[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'planeDistance'], values);
   } else if (key==='ParallelTranslation[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'planeDistance'], values);
   } else if (key==='Rotation[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'degrees'], values);
   }
}
function _opt(wp) {
  return Object.values(wp)[0].map(g=>{ 
   let key = Object.keys(g)[0];
   let value = Object.values(g)[0];
   return `<option value="${key}:${value}">${key}</option>`;
  }).join('');
}
function _origin () {
  return '<circle cx="0" cy="0" r="0.03"></circle>';
}
function _svg (wp) {
  let plane = () => `<g transform="scale(6)"><rect x="-1" y="-1" width="1" height="2" opacity="0.2"></rect></g>`;
  let segment = () => `<line x1="0" y1="0" x2="0" y2="1"></line>`;
  let line = () => `<g transform="scale(1,6)"><line x1="0" y1="-1" x2="0" y2="1"></line></g>`;
  let arc = (deg) => {
    let theta = deg*Math.PI/180;
    let x1 = Math.cos(theta);
    let y1 = Math.sin(theta);
    return `<path d="M ${x1} ${y1} A 1 1 ${deg} 0 0 1 0"></path>`;
  }
  return Object.values(wp)[0].map(g=>{ 
   let key = Object.keys(g)[0];
   let value = Object.values(g)[0]
   if (key==='HalfPlane[]') {
     let [pointX, pointY, normalX, normalY] = value;
     let [x1,y1]= [pointX, pointY];
     let rot = Math.atan2(normalY,normalX)*180/Math.PI;
     let ret = `<g transform="translate(${x1},${y1})rotate(${rot})" fill="red">${plane()}</g>`;
     return ret;
   } else if (key==='CrossingInversions[]') {
     let [pointX, pointY, directionX, directionY, degrees] = value;
     let [x1,y1]= [pointX, pointY];
     let rot = Math.atan2(directionY,directionX)*180/Math.PI;
     let ret = `<g stroke="purple">
<g transform="translate(${x1},${y1})rotate(${rot})">
<g stroke-width="0.02" transform="rotate(90)">
${line()}
</g>
<g stroke-width="0.02" transform="rotate(90)rotate(${degrees})">
${line()}
</g>
<g stroke-width="0.05" fill="none" marker-end="url(#purpleendarrow)" marker-start="url(#purplestartarrow)">
${arc(degrees)}
</g>
<g stroke-width="0.02">
<circle cx="0" cy="0" r="0.05">
</g>
</g>
</g>`;
     return ret;
   } else if (key==='GlideReflection[]') {
     let [pointX, pointY, directionX, directionY, planeDistance] = value;
     let [x1,y1]= [pointX, pointY];
     let rot = Math.atan2(directionY,directionX)*180/Math.PI;
     let ret = `<g stroke-width="0.01" fill="orange">
<g transform="translate(${x1},${y1})rotate(${rot})">
${plane()}
<g stroke="orange" transform="rotate(-90)scale(1,${planeDistance})" stroke-width="0.05" marker-end="url(#orangeendarrow)" marker-start="url(#orangestartarrow)">
${segment()}
</g>
<g transform="translate(${planeDistance})rotate(180)">
${plane()}
</g>
</g>
</g>`;
     return ret;
/*
   } else if (key==='ParallelInversions[]') {
     let [pointX, pointY, directionX, directionY, planeDistance] = value;
*/
   } else if (key==='ParallelTranslation[]') {
     let [pointX, pointY, directionX, directionY, planeDistance] = value;
     let [x1,y1]= [pointX, pointY];
     let rot = Math.atan2(directionY,directionX)*180/Math.PI;
     let ret = `<g stroke-width="0.01" fill="blue">
<g transform="translate(${x1},${y1})rotate(${rot})">
${plane()}
<g stroke="blue" transform="rotate(-90)scale(1,${planeDistance})" stroke="blue" stroke-width="0.05" marker-end="url(#endarrow)" marker-start="url(#startarrow)">
${segment()}
</g>
<g transform="translate(${planeDistance})rotate(180)">
${plane()}
</g>
</g>
</g>`;
     return ret;
   } else if (key==='Rotation[]') {
     let  [pointX, pointY, directionX, directionY, degrees] = value;
     let [x1,y1]= [pointX, pointY];
     let rot = Math.atan2(directionY,directionX)*180/Math.PI;
     let ret = `<g fill="green">
<g transform="translate(${x1},${y1})rotate(${rot})">
<g stroke-width="0.02" transform="rotate(90)">
${plane()}
</g>
<g stroke-width="0.02" transform="rotate(270)rotate(${degrees})">
${plane()}
</g>
<g stroke="green" stroke-width="0.05" fill="none" marker-end="url(#greenendarrow)" marker-start="url(#greenstartarrow)">
${arc(degrees)}
</g>
<g stroke-width="0.02">
<circle cx="0" cy="0" r="0.05">
</g>
</g>
</g>`;
     return ret;
   }
   return '';
  }).join('')
}
let wps = [];
localStorage.removeItem('wpi');
updateMenu(1.2);

function updateMenu(param_x) {
const _wps = [
{ "IH92: p6m = rot +halfp x2 ": [
     {"Rotation[]":[-1/2,0, Math.sqrt(3),-1, 60]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,0, -1, 0]},
]},
{ "IH77=93: p6m = halfp x3 ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[1.4,0,-Math.sqrt(3),-1]},
]},
{ "IH90: p6 = rot x3 ": [
     {"Rotation[]":[1-1.5/2, 1.5/2/Math.sqrt(3)+0.5,-Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1-1.5/2,-1.5/2/Math.sqrt(3)+0.5, Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1,0.5, 0, 1, 180]},
]},
{ "IH88: p6 = rot x2 ": [
     {"Rotation[]":[-1/2,0.5, Math.sqrt(3),-1, 60]},
     {"Rotation[]":[1,0.5, 0, 1, 180]},
]},
{ "IH39: p6 = rot x2 ": [
     {"Rotation[]":[-1/3,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[1, 0.5, 0, 1, 180]},
]},
{ "IH31: p6 = rot x2 ": [
     {"Rotation[]":[0,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[2,0.5, -Math.sqrt(3), 1, 60]},
]},
{ "IH38=36=89: p31m = halfp x1 +rot ": [
     {"HalfPlane[]":[-1.2, 1.2*Math.sqrt(3), -1, -Math.sqrt(3)]},
     {"Rotation[]":[0,0, 1, 0, 120]},
]},
{ "IH30: p31m = rot +halfp x2 ": [
     {"Rotation[]":[-1/Math.sqrt(3),1, 1, -Math.sqrt(3), 120]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,2, -Math.sqrt(3),-1]},
]},
{ "IH87=19: p3m1 = halfp x3 ": [
     {"HalfPlane[]":[-0.3,0, 0, 1]},
     {"HalfPlane[]":[-0.3,0, Math.sqrt(3),-1]},
     {"HalfPlane[]":[1.4,0,-Math.sqrt(3),-1]},
]},
{ "IH33: p3 = rot x2 ": [
     {"Rotation[]":[-0.2,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[1.2,0.5, -1, Math.sqrt(3), 120]},
]},
{ "IH81: p4g = rot +halfp ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"HalfPlane[]":[Math.sqrt(2)+0.2,0, -1, -1]},
]},
{ "IH71: p4g = halfp + glide ": [
     {"GlideReflection[]":[0+1.5/2/Math.sqrt(2),0.5-1.5/2/Math.sqrt(2), 1, 1, 1.5]},
     {"GlideReflection[]":[0+1.5/2/Math.sqrt(2),0.5+1.5/2/Math.sqrt(2), 1, -1,1.5]},
     {"HalfPlane[]":[1.5/Math.sqrt(2),0, -1, 0]},
]},
{ "IH56: p4g = rot +halfp x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"HalfPlane[]":[1,0, -1, 0]},
     {"HalfPlane[]":[0,1, 0, -1]},
]},
{ "IH80=82: p4m = halfp x3 ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[1.6,0,-1,-1]},
]},
{ "IH79: p4 = rot x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"Rotation[]":[1,1, -1,1, 180]},
]},
{ "IH55: p4 = rot x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"Rotation[]":[1,1, -1,0, 90]},
]},
{ "IH78=74: cmm = rot +halfplane x2 ": [
     {"HalfPlane[]":[0,0, 1,0]},
     {"HalfPlane[]":[0,0, 0,1]},
     {"HalfPlane[]":[Math.sqrt(2)+0.2,0, -1, -1]},
]},
{ "IH52: pgg = glide x2 ": [
     {"GlideReflection[]":[  0, 0.5, 1, 0, param_x]},
     {"GlideReflection[]":[param_x/2,   0, 0, 1, 1]},
]},
{ "IH51: pgg = glide +rotate x2 ": [
     {"GlideReflection[]":[0, 0.5, 1, 0, param_x]},
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"Rotation[]":[param_x/2,1, -1, 0, 180]},
]},
{ "IH85=69: pmg rot x2 + halfp ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"Rotation[]":[0,1/2, 0, -1, 180]},
     {"HalfPlane[]":[param_x,0,-1, -param_x]},
]},
{ "IH58: pmg = rot +halfp +para ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[param_x,0, -1, 0]},
     {"ParallelTranslation[]":[param_x/2,-1, 0, 1, 2]},
]},
{ "IH50=66: pmg = rot +para +halfp": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"HalfPlane[]":[0,1, 0, -1]},
     {"ParallelTranslation[]":[0, 0.5, 1, 0, param_x]},
]},
{ "IH49: pmg = rot x2 +halfp x2 ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"Rotation[]":[param_x/2,1,-1, 0, 180]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[param_x, 0, -1,0]},
]},
{ "IH13: pmg = para +halfp +rot x2 ": [
     {"ParallelTranslation[]":[0,3/4/Math.sqrt(3), 1, 0,1]},
     {"HalfPlane[]":[0.5,0.5/Math.sqrt(3), 0, 1]},
     {"Rotation[]":[1/4,5/4/Math.sqrt(3), -Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,5/4/Math.sqrt(3),-Math.sqrt(3),1, 180]},
]},
{ "IH72: pmm = para x2 +halfp x2 ": [
     {"HalfPlane[]":[0,1, 0,-1]},
     {"HalfPlane[]":[param_x,0, -1,0]},
     {"ParallelTranslation[]":[param_x/2, 0, 0, 1, 2]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x*2]},
]},
{ "IH65: pmm = para +halfp x3 ": [
     {"HalfPlane[]":[0,1, 0,-1]},
     {"HalfPlane[]":[0,0, 0,1]},
     {"HalfPlane[]":[param_x,0, -1,0]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x*2]},
]},
{ "IH48: pmm = halfp x4 ": [
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[param_x,0,-1, 0]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,1, 0,-1]},
]},
{ "IH68: cm = para x2 + halfp ": [
     {"ParallelTranslation[]":[0+1.5/2/Math.sqrt(2),0.5-1.5/2/Math.sqrt(2), 1, 1, 1.5]},
     {"ParallelTranslation[]":[0+1.5/2/Math.sqrt(2),0.5+1.5/2/Math.sqrt(2), 1, -1,1.5]},
     {"HalfPlane[]":[1.5/Math.sqrt(2),0, -1, 0]},
]},
{ "IH45: cm = halfp x2 +glide ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,1, 0,-1]},
     {"GlideReflection[]":[0,0.5, 1, 0, param_x]},
]},
/*
{ "IH83: cm = halfp +gliderot ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,1, 0,-1]},
     {"GlideReflection[]":[0,0.5, 1, 0, 1]},
]},
*/
{ "IH43: pg = para +glide ": [
     {"GlideReflection[]":[0,0.5, 1, 0, param_x]},
     {"ParallelTranslation[]":[param_x/2,0, 0, 1, 1]},
]},
{ "IH64: pm = para x2	+halfp ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"ParallelTranslation[]":[param_x/2,-1, 0, 1, 2]}, 
]},
{ "IH42=64: pm = para	+halfp x2 ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,1, 0,-1]},
]},
{ "IH84: p2 = rot x3 ": [
     {"Rotation[]":[param_x,0, 1, 0, 180]},
     {"Rotation[]":[0,1, 0,-1, 180]},
     {"Rotation[]":[param_x,1,-param_x, 1, 180]},
]},
{ "IH57: p2 = para x2	+rot ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x]}, 
     {"ParallelTranslation[]":[param_x/2,1, 0, -1, 2]}, 
]},
{ "IH47: p2 = para +rot x2 ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"Rotation[]":[param_x/2,1,-1, 0, 180]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x]}, 
]},
{ "IH46: p2 = rot x4 ": [
     {"Rotation[]":[param_x/2,0, 1, 0, 180]},
     {"Rotation[]":[param_x/2,1,-1, 0, 180]},
     {"Rotation[]":[0,0.5, 0,-1, 180]},
     {"Rotation[]":[param_x,0.5, 0, 1, 180]},
]},
{ "IH8=23: p2 = para  +rot x3 ": [
     {"ParallelTranslation[]":[0,1/4/Math.sqrt(3), 1, 0,1]},
     {"Rotation[]":[0.5,0.5/Math.sqrt(3), -1, 0,180]},
     {"Rotation[]":[1/4,-1/4/Math.sqrt(3),Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,-1/4/Math.sqrt(3), Math.sqrt(3),1, 180]},
]},
{ "IH2: p2 = para +rot x4 ": [
     {"ParallelTranslation[]":[0,0.5/Math.sqrt(3), 1, 0,1]},
     {"Rotation[]":[1/4,-1/4/Math.sqrt(3),Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1/4,5/4/Math.sqrt(3), -Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,5/4/Math.sqrt(3),-Math.sqrt(3),1, 180]},
     {"Rotation[]":[3/4,-1/4/Math.sqrt(3), Math.sqrt(3),1, 180]},
]},
{ "IH41: p1 = para x2 ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, param_x]},
     {"ParallelTranslation[]":[param_x/2,0, 0, 1, 1]},
]},
{ "IH1: p1 = para x3 ": [
     {"ParallelTranslation[]":[0,0.5/Math.sqrt(3), 1, 0,1]},
     {"ParallelTranslation[]":[1/4,-1/4/Math.sqrt(3), 1,Math.sqrt(3), 1]},
     {"ParallelTranslation[]":[1/4,5/4/Math.sqrt(3), 1,-Math.sqrt(3), 1]},
]},
];
wps.length=0;
let menu = document.querySelector('div#menu');
menu.innerHTML = '';

_wps.forEach((wp,i)=>{
wps.push(wp);
menu.insertAdjacentHTML('afterbegin',`<li><a id="a${i}" target="_blank" onmouseover="svg(${i},this.textContent);" href="?title=${Object.keys(wp)[0]}&scale=8&OrbitSeed[]=0,0,1,1&${qs(wp)}">${Object.keys(wp)[0]}</a>`);
});

}
</script>
<br/>
<br/>
</body>
</html>
