
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<base href="https://soma-arc.net/SchottkyV3/">
</head>
<body>
<div style="display: flex;justify-content: flex-end;position:sticky;top:0;">
  <div style="position:absolute;">

<form>
<input size="50" value="https://soma-arc.net/SchottkyV3/" onchange="
 localStorage.setItem('base_href',this.value);
 document.querySelector('html >  head > base').setAttribute('href',this.value);
">
<script>
let base_href = localStorage.getItem('base_href');
if (base_href && /^https*:\/\//.test(base_href)) {
  document.currentScript.closest('form').querySelector('input').value = base_href;
}
</script>
</form>
    <div id="svgbase"></div>
  </div>
</div>
<div id="menu">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<script>
(()=>{with(paper){
  const WALLPAPER = { };
  window.addEventListener('load',()=>{setup(draw);});
  init(draw);
  return;

function draw() {
  let booled = null;
  Object.values(WALLPAPER.wp)[0].map(kv=>{
    let key = Object.keys(kv)[0];
    let value = Object.values(kv)[0];
    let color = WALLPAPER.color[key];
    let color_a = 'black';
    let color_b = 'purple';
   
    if (key==='HalfPlane[]') {
      let inst = WALLPAPER.defs[key].place();
      let [pointX, pointY, normalX, normalY] = value;
      let [x1,y1]= [pointX, pointY];
      let rot = Math.atan2(normalY,normalX)*180/Math.PI;
      inst.rotate(rot,[0,0]);
      inst.translate(x1,y1);
      let tmp = inst.definition.item.children[1].copyTo(project);
      tmp.rotate(rot,[0,0]);
      tmp.translate(x1,y1);
      tmp.strokeColor = color_a;
      tmp.strokeWidth = 0.012;
      if (!booled) {
        booled = tmp;
      } else {
        booled = booled.intersect(tmp, {insert: false});
      }
      tmp.remove();
    } else if ((key==='ParallelTranslation[]')
      || (key==='GlideReflection[]')) {
      let inst = WALLPAPER.defs[key].place();
      let [pointX, pointY, directionX, directionY, planeDistance] = value;
      let [x1,y1]= [pointX, pointY];
      let rot = Math.atan2(directionY,directionX)*180/Math.PI;
      inst.rotate(rot,[0,0]);
      inst.translate(x1,y1);

      let theta = rot*Math.PI/180;
      let [x2,y2] = [
        x1+planeDistance*Math.cos(theta),
        y1+planeDistance*Math.sin(theta)
      ];
      let rot2 = rot + 180;
      let inst2 = WALLPAPER.defs[key].place();
      inst2.rotate(rot2,[0,0]);
      inst2.translate(x2,y2);

      let tmp = inst.definition.item.children[1].copyTo(project);
      tmp.rotate(rot,[0,0]);
      tmp.translate(x1,y1);
      tmp.strokeColor = color_a;
      tmp.strokeWidth = 0.01;

      let tmp2 = inst2.definition.item.children[1].copyTo(project);
      tmp2.rotate(rot2,[0,0]);
      tmp2.translate(x2,y2);
      tmp2.strokeColor = color_a;
      tmp2.strokeWidth = 0.01;

      let tmp3 = tmp.intersect(tmp2,{insert:false});
      if (!booled) {
        booled = tmp3;
      } else {
        booled = booled.intersect(tmp3, {insert: false});
      }
      tmp.remove();
      tmp2.remove();

      let line = new Path.Line({
        from: [0,0],
        to: [planeDistance,0],
        strokeColor: color,
        strokeWidth: 0.015
      });
      line.rotate(rot,[0,0]);
      line.translate([x1,y1]);
      let tip = 0.12;
      let arrow = new Path({
        segments: [[0,0],[tip*3/7,tip],[0,tip]],
        fillColor: color,
      });
      let arrow2;
      if (key==='ParallelTranslation[]') {
        arrow2 = arrow.clone();
      } else {
        arrow2 = new Path({
          segments: [[0,0],[-tip*3/7,tip],[0,tip]],
          fillColor: color,
        });
      }
      arrow.rotate(rot-90,[0,0]);
      arrow.translate([x1,y1]);

      arrow2.translate(0,-tip);
      arrow2.rotate(rot-90,[0,0]);
      arrow2.translate([x2,y2]);

    } else if (key==='Rotation[]') {
      let inst = WALLPAPER.defs[key].place();
      let  [pointX, pointY, directionX, directionY, degrees] = value;
      let [x1,y1]= [pointX, pointY];
      let rot = Math.atan2(directionY,directionX)*180/Math.PI;
      inst.rotate(rot+90,[0,0]);
      inst.translate(x1,y1);

      let rot2 = rot + degrees;
      let inst2 = WALLPAPER.defs[key].place();
      inst2.rotate(rot2+90+180,[0,0]);
      inst2.translate(x1,y1);

      let tmp = inst.definition.item.children[1].copyTo(project);
      tmp.rotate(rot+90,[0,0]);
      tmp.translate(x1,y1);
      tmp.strokeColor = color_a;
      tmp.strokeWidth = 0.01;

      let tmp2 = inst2.definition.item.children[1].copyTo(project);
      tmp2.rotate(rot2+90+180,[0,0]);
      tmp2.translate(x1,y1);
      tmp2.strokeColor = color_a;
      tmp2.strokeWidth = 0.01;

      let tmp3 = tmp.intersect(tmp2,{insert:false});
      if (!booled) {
        booled = tmp3;
      } else {
        booled = booled.intersect(tmp3, {insert: false});
      }
      tmp.remove();
      tmp2.remove();

      let size = 1.2;
      let theta = rot*Math.PI/180;
      let theta2 = (rot+degrees/2)*Math.PI/180;
      let theta3 = (rot+degrees)*Math.PI/180;
      let [fx,fy] = [size*Math.cos(theta),size*Math.sin(theta)];
      let [hx,hy] = [size*Math.cos(theta2),size*Math.sin(theta2)];
      let [tx,ty] = [size*Math.cos(theta3),size*Math.sin(theta3)];
      let arc = new Path.Arc({
        from: [fx,fy],
        through: [hx,hy],
        to: [tx,ty],
        strokeColor: color,   
        strokeWidth: 0.012,
      });
      arc.translate(x1,y1);

      let tip = 0.1;
      let arrow = new Path({
        segments: [[-tip*2/7,0],[tip*2/7,0],[0,tip]],
        fillColor: color,
      });
      let arrow2 = arrow.clone();
      arrow.rotate(rot,[0,0]);
      arrow.translate(x1+fx,y1+fy);

      arrow2.translate(0,-tip);
      arrow2.rotate(rot2,[0,0]);
      arrow2.translate(x1+tx,y1+ty);
    }
  });
  if (booled) {
    booled.addTo(project.activeLayer);
    saveBBox(booled);
  }
  new Shape.Circle({
    center: [0,0],
    radius: 0.03,
    fillColor: "black"
  });
  WALLPAPER.svgbase.querySelector('svg > g').innerHTML = (project.exportSVG().innerHTML);
  return;

  function saveBBox () {
    let minX=1000;
    let maxX=-1000;
    let minY=1000;
    let maxY=-1000;
    booled.segments.map(s=>{
      if ( s.point.x < minX ) { minX = s.point.x.toFixed(4); }
      if ( s.point.x > maxX ) { maxX = s.point.x.toFixed(4); }
      if ( s.point.y < minY ) { minY = s.point.y.toFixed(4); }
      if ( s.point.y > maxY ) { maxY = s.point.y.toFixed(4); }
      //console.log(s.point.x+' '+s.point.y);
    });
    WALLPAPER.svgbase.setAttribute('x-bbox',[minX,minY,maxX,maxY].join(','));
    let path = new Path.Rectangle({
      from: [minX,minY],
      to: [maxX,maxY],
      strokeWidth: 0.01,
      strokeColor: 'black',
      dashArray: [0.03,0.03],
    });
  }
}
function setup(callback) {
  paper.setup(document.getElementById('myCanvas'));
  paper.view.center = [0,0];
  paper.view.zoom = 80;
  WALLPAPER.defs = {};
  Object.keys(WALLPAPER.color).map(key=>{
    WALLPAPER.defs[key] = plane(WALLPAPER.color[key]);
  });
  callback();
  return;

  function plane (color) {
    const PLANE_SIZE = 10;
    let halfp =  new Path.Rectangle( new Rectangle({
      point: [-PLANE_SIZE,-PLANE_SIZE],
      size: [PLANE_SIZE,PLANE_SIZE*2],
    }));
    halfp.fillColor= color;
    halfp.opacity= 0.2;
    let dummy =  new Path.Rectangle( new Rectangle({
      point: [0,-PLANE_SIZE],
      size: [PLANE_SIZE,PLANE_SIZE*2],
    }));
    return new SymbolDefinition(new Group([halfp,dummy]));
  }
}
function init(callback) {
  const WIDTH = 500;
  const HEIGHT = 500;
  const pkey = ['x','a','b','c'];
  WALLPAPER.svgbase = document.querySelector('div#svgbase');
  WALLPAPER.svgbase.insertAdjacentHTML('beforeend',`
  <canvas style="display:none;" id="myCanvas" width="${WIDTH}" height="${HEIGHT}"></canvas>
  <svg width="${WIDTH}" height="${HEIGHT}"><g transform="translate(${WIDTH/2},${HEIGHT/2})scale(1,-1)translate(${-WIDTH/2},${-HEIGHT/2})">
  </g></svg>
`);
  WALLPAPER.svgbase.insertAdjacentHTML('afterend',`
<p>
<div style="display:flex;">
  <div>
    <select name="detail" style="width:150px;height:100px;" multiple="multiple">
    </select>
  </div>
  <div id="detail_label" style="width:80px;margin-left:10px;">
  </div>
  <div id="detail_input" style="margin-left:10px;">
  </div>
</div>
`);
  let button = document.createElement('button');
  button.innerText = 'view';
  button.addEventListener('click',_view);
  WALLPAPER.svgbase.insertAdjacentElement('afterend',button);

  WALLPAPER.input = {}; 
  pkey.reverse().map(p=>{
    let input = document.createElement('input');
    input.name = p;
    WALLPAPER.input[p] = input; 
    input.type = 'range';
    input.value = 1;
    input.setAttribute('min','0');
    input.setAttribute('max','2');
    input.setAttribute('step','0.1');
    input.addEventListener('change',redraw);
    WALLPAPER.svgbase.insertAdjacentElement('afterend',input);
    WALLPAPER.svgbase.insertAdjacentHTML('afterend',`<br/><input size="5" disabled="disabled" value="${p}">`);
  });
  WALLPAPER.svgbase.insertAdjacentHTML('afterend',`
<input name="title" size="50">
<br/>
`);
  document.querySelector('select[name="detail"]').addEventListener('change',_detail);
  WALLPAPER.color = {
    'HalfPlane[]': 'red',
    'ParallelTranslation[]': 'blue',
    'Rotation[]': 'green',
    'GlideReflection[]': 'orange',
  };
  redraw();
  return;

  function redraw (ev) {
    let pval = {};
    pkey.map(p=>{
      pval[p] = parseFloat(WALLPAPER.input[p].value);
    });
    const _wps = getWps(pval);
    let source='init';
    if (ev) {
      let target = ev.target;
      if (target.tagName.toLowerCase()==='a') {
        source='anchor';
      } else {
        source='range';
      }
    }
    let wpi = 0;
    if (source==='anchor') {
      let xid = ev.target.getAttribute('x-id');
      if (xid && xid.length>0) {
        wpi = parseInt(xid,10);
      }
    } else if (source==='range') {
      wpi = getWpi();
    }
    WALLPAPER.wp = _wps[wpi];
    if (!(source==='init')) {
      project.clear()
      callback(ev);
    }
    let title = Object.keys(WALLPAPER.wp)[0];
    if (title) {
      document.querySelector('input[name=title]').value = title;
    }
    setWpi(wpi);
    document.querySelector('select').innerHTML = _opt();
    if (!(source==='anchor')) {
      _menu(_wps);
    }
  }
  function _opt() {
    return Object.values(WALLPAPER.wp)[0].map(g=>{
     let key = Object.keys(g)[0];
     let value = Object.values(g)[0];
     return `<option value="${key}:${value}">${key}</option>`;
    }).join('');
  }  
  function _detail (e) {
    kv = e.target.value;
    let [key,valstr]=kv.split(':');
    let values = valstr.split(',');
    if (key==='HalfPlane[]') {
      _input(['pointX', 'pointY', 'normalX', 'normalY'], values);
    } else if (key==='GlideReflection[]') {
      _input(['pointX', 'pointY', 'directionX', 'directionY', 'planeDistance'], values);
    } else if (key==='ParallelTranslation[]') {
     _input(['pointX', 'pointY', 'directionX', 'directionY', 'planeDistance'], values);
    } else if (key==='Rotation[]') {
      _input(['pointX', 'pointY', 'directionX', 'directionY', 'degrees'], values);
    }
    return;

    function _input (labels,values) {
      let ret = [];
      document.querySelector('div#detail_label').innerHTML
    = labels.map(label=>{
       return `<input size="12" disabled="disabled" value="${label}"><br/>`
      }).join('');
      values.forEach((value,i)=>{
        ret.push(`<input size="15" name="${labels[i]}" value="${value}"><br/>`);
      });
      document.querySelector('div#detail_input').innerHTML = ret.join('');
    }
  }
  function qs (wp) {
    return Object.values(wp)[0].map(g=>{ return Object.keys(g)[0]+'='+Object.values(g)[0].join(',')}).join('&')
  }
  function setWpi (wpi) {
    WALLPAPER.svgbase.setAttribute('x-id',wpi);
  }
  function getWpi () {
    let xid = WALLPAPER.svgbase.getAttribute('x-id');
    if (xid && xid.length>0) {
      wpi = parseInt(xid,10);
    }
    return wpi;
  }
  function _view() {
    let wpi = getWpi();
    document.querySelector(`a[x-id="${wpi}"]`).click();
  }
  function _menu (_wps) {
    let menu = document.querySelector('div#menu');
    menu.innerHTML = '';
    let xid=0;
    _wps.map(g=>{
      let a = document.createElement('a');
      let title = Object.keys(g)[0];
      a.innerText = title;
      a.href = encodeURI(`?title=${title}&scale=8&OrbitSeed[]=${getBBox()}&${qs(g)}`);
      a.setAttribute('x-id',xid); 
      a.target = '_blank';
      a.addEventListener('mouseover',redraw);
      menu.insertAdjacentHTML('beforeend','<dd>');
      menu.insertAdjacentElement('beforeend',a);
      xid++;
    });
  }
} // init
function getBBox () {
  let bbox = WALLPAPER.svgbase.getAttribute('x-bbox');
  if (bbox) {
    return bbox;
  } else {
    return '-0.5,-0.5,0.5,0.5';
  }
}
function getWps (pval) {
return [
{ "IH1: p1 = para x3 ": [
     {"ParallelTranslation[]":[0,0.5/Math.sqrt(3), 1, 0,1]},
     {"ParallelTranslation[]":[1/4,-1/4/Math.sqrt(3), 1,Math.sqrt(3), 1]},
     {"ParallelTranslation[]":[1/4,5/4/Math.sqrt(3), 1,-Math.sqrt(3), 1]},
]},
{ "IH41: p1 = para x2 ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x]},
     {"ParallelTranslation[]":[pval.x/2,0, 0, 1, 1]},
]},
{ "IH2: p2 = para +rot x4 ": [
     {"ParallelTranslation[]":[0,0.5/Math.sqrt(3), 1, 0,1]},
     {"Rotation[]":[1/4,-1/4/Math.sqrt(3),Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1/4,5/4/Math.sqrt(3), -Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,5/4/Math.sqrt(3),-Math.sqrt(3),1, 180]},
     {"Rotation[]":[3/4,-1/4/Math.sqrt(3), Math.sqrt(3),1, 180]},
]},
{ "IH8=23: p2 = para  +rot x3 ": [
     {"ParallelTranslation[]":[0,1/4/Math.sqrt(3), 1, 0,1]},
     {"Rotation[]":[0.5,0.5/Math.sqrt(3), -1, 0,180]},
     {"Rotation[]":[1/4,-1/4/Math.sqrt(3),Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,-1/4/Math.sqrt(3), Math.sqrt(3),1, 180]},
]}, 
{ "IH46: p2 = rot x4 ": [
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"Rotation[]":[pval.x/2,1,-1, 0, 180]},
     {"Rotation[]":[0,0.5, 0,-1, 180]},
     {"Rotation[]":[pval.x,0.5, 0, 1, 180]},
]},
{ "IH47: p2 = para +rot x2 ": [
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"Rotation[]":[pval.x/2,1,-1, 0, 180]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x]},
]},
{ "IH57: p2 = para x2   +rot ": [
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x]},
     {"ParallelTranslation[]":[pval.x/2,1, 0, -1, 2]}, 
]},
{ "IH84: p2 = rot x3 ": [
     {"Rotation[]":[pval.x,0, 1, 0, 180]},
     {"Rotation[]":[0,1, 0,-1, 180]},
     {"Rotation[]":[pval.x,1,-pval.x, 1, 180]},
]},
{ "IH42=64: pm = para   +halfp x2 ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,1, 0,-1]},
]},
{ "IH64: pm = para x2   +halfp ": [
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"ParallelTranslation[]":[pval.x/2,-1, 0, 1, 2]},
]},
{ "IH43: pg = para +glide ": [
     {"GlideReflection[]":[0,0.5, 1, 0, pval.x]},
     {"ParallelTranslation[]":[pval.x/2,0, 0, 1, 1]},
]},
{ "IH45: cm = halfp x2 +glide ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,1, 0,-1]}, 
     {"GlideReflection[]":[0,0.5, 1, 0, pval.x]},
]},
{ "IH68: cm = para x2 + halfp ": [
     {"ParallelTranslation[]":[0+1.5/2/Math.sqrt(2),0.5-1.5/2/Math.sqrt(2), 1, 1, 1.5]},
     {"ParallelTranslation[]":[0+1.5/2/Math.sqrt(2),0.5+1.5/2/Math.sqrt(2), 1, -1,1.5]},
     {"HalfPlane[]":[1.5/Math.sqrt(2),0, -1, 0]},
]},
{ "IH48: pmm = halfp x4 ": [ 
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[pval.x,0,-1, 0]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,1, 0,-1]},
]},
{ "IH65: pmm = para +halfp x3 ": [
     {"HalfPlane[]":[0,1, 0,-1]},
     {"HalfPlane[]":[0,0, 0,1]},
     {"HalfPlane[]":[pval.x,0, -1,0]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x*2]},
]},
{ "IH72: pmm = para x2 +halfp x2 ": [
     {"HalfPlane[]":[0,1, 0,-1]},
     {"HalfPlane[]":[pval.x,0, -1,0]},
     {"ParallelTranslation[]":[pval.x/2, 0, 0, 1, 2]},
     {"ParallelTranslation[]":[0,0.5, 1, 0, pval.x*2]},
]},
{ "IH13: pmg = para +halfp +rot x2 ": [
     {"ParallelTranslation[]":[0,3/4/Math.sqrt(3), 1, 0,1]},
     {"HalfPlane[]":[0.5,0.5/Math.sqrt(3), 0, 1]},
     {"Rotation[]":[1/4,5/4/Math.sqrt(3), -Math.sqrt(3),-1, 180]},
     {"Rotation[]":[3/4,5/4/Math.sqrt(3),-Math.sqrt(3),1, 180]},
]},
{ "IH49: pmg = rot x2 +halfp x2 ": [
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"Rotation[]":[pval.x/2,1,-1, 0, 180]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[pval.x, 0, -1,0]},
]},
{ "IH50=66: pmg = rot +para +halfp": [ 
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"HalfPlane[]":[0,1, 0, -1]},
     {"ParallelTranslation[]":[0, 0.5, 1, 0, pval.x]},
]},
{ "IH58: pmg = rot +halfp +para ": [
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[pval.x,0, -1, 0]},
     {"ParallelTranslation[]":[pval.x/2,-1, 0, 1, 2]},
]},
{ "IH85=69: pmg rot x2 + halfp ": [ 
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"Rotation[]":[0,1/2, 0, -1, 180]},
     {"HalfPlane[]":[pval.x,0,-1, -pval.x]},
]},
{ "IH51: pgg = glide +rotate x2 ": [
     {"GlideReflection[]":[0, 0.5, 1, 0, pval.x]},
     {"Rotation[]":[pval.x/2,0, 1, 0, 180]},
     {"Rotation[]":[pval.x/2,1, -1, 0, 180]},
]},
{ "IH52: pgg = glide x2 ": [
     {"GlideReflection[]":[  0, 0.5, 1, 0, pval.x]},
     {"GlideReflection[]":[pval.x/2,   0, 0, 1, 1]},
]},
{ "IH78=74: cmm = rot +halfplane x2 ": [
     {"HalfPlane[]":[0,0, 1,0]},
     {"HalfPlane[]":[0,0, 0,1]},
     {"HalfPlane[]":[Math.sqrt(2)+0.2,0, -1, -1]},
]},
{ "IH55: p4 = rot x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"Rotation[]":[1,1, -1,0, 90]},
]},
{ "IH79: p4 = rot x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"Rotation[]":[1,1, -1,1, 180]},
]},
{ "IH80=82: p4m = halfp x3 ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[1.6,0,-1,-1]},
]},
{ "IH56: p4g = rot +halfp x2 ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"HalfPlane[]":[1,0, -1, 0]},
     {"HalfPlane[]":[0,1, 0, -1]},
]},
{ "IH71: p4g = halfp + glide ": [
     {"GlideReflection[]":[0+1.5/2/Math.sqrt(2),0.5-1.5/2/Math.sqrt(2), 1, 1, 1.5]},
     {"GlideReflection[]":[0+1.5/2/Math.sqrt(2),0.5+1.5/2/Math.sqrt(2), 1, -1,1.5]},
     {"HalfPlane[]":[1.5/Math.sqrt(2),0, -1, 0]},
]},
{ "IH81: p4g = rot +halfp ": [
     {"Rotation[]":[0,0, 1, 0, 90]},
     {"HalfPlane[]":[Math.sqrt(2)+0.2,0, -1, -1]},
]},
{ "IH33: p3 = rot x2 ": [
     {"Rotation[]":[-0.2,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[1.2,0.5, -1, Math.sqrt(3), 120]},
]},
{ "IH87=19: p3m1 = halfp x3 ": [
     {"HalfPlane[]":[-0.3,0, 0, 1]},
     {"HalfPlane[]":[-0.3,0, Math.sqrt(3),-1]},
     {"HalfPlane[]":[1.4,0,-Math.sqrt(3),-1]},
]},
{ "IH30: p31m = rot +halfp x2 ": [
     {"Rotation[]":[-1/Math.sqrt(3),1, 1, -Math.sqrt(3), 120]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,2, -Math.sqrt(3),-1]},
]},
{ "IH38=36=89: p31m = halfp x1 +rot ": [
     {"HalfPlane[]":[-1.2, 1.2*Math.sqrt(3), -1, -Math.sqrt(3)]},
     {"Rotation[]":[0,0, 1, 0, 120]},
]},
{ "IH31: p6 = rot x2 ": [
     {"Rotation[]":[0,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[2,0.5, -Math.sqrt(3), 1, 60]},
]},
{ "IH39: p6 = rot x2 ": [
     {"Rotation[]":[-1/3,0.5, 1, -Math.sqrt(3), 120]},
     {"Rotation[]":[1, 0.5, 0, 1, 180]},
]},
{ "IH88: p6 = rot x2 ": [
     {"Rotation[]":[-1/2,0.5, Math.sqrt(3),-1, 60]},
     {"Rotation[]":[1,0.5, 0, 1, 180]},
]},
{ "IH90: p6 = rot x3 ": [
     {"Rotation[]":[1-1.5/2, 1.5/2/Math.sqrt(3)+0.5,-Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1-1.5/2,-1.5/2/Math.sqrt(3)+0.5, Math.sqrt(3),-1, 180]},
     {"Rotation[]":[1,0.5, 0, 1, 180]},
]},
{ "IH77=93: p6m = halfp x3 ": [
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[0,0, 1, 0]},
     {"HalfPlane[]":[1.4,0,-Math.sqrt(3),-1]},
]},
{ "IH92: p6m = rot +halfp x2 ": [
     {"Rotation[]":[-1/2,0, Math.sqrt(3),-1, 60]},
     {"HalfPlane[]":[0,0, 0, 1]},
     {"HalfPlane[]":[1,0, -1, 0]},
]},
    ];
}
}})();
</script>
</body>
</html>
