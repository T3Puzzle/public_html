
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=0.6, minimum-scale=0.6, maximum-scale=1.0, user-scalable=no" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<style>
 button {
   background-color: yellow;
   color: black;
   text-align: center;
   font-size: 25px;
   margin-left:3px;
 }
 body {
   user-select: none;
   touch-action: none;
   -webkit-user-select: none;
   margin-left:0px;
   margin-right:0px;
   margin-top:5px;
 }
 dd {
   margin-left:10px;
   font-size: 25px;
 }
 div {
   text-align: center;
 }
</style>
</head>
<body onload="setup()">
<div>
<h1>Aperiodic Tile Deformation</h1>
<dd>Shape:<input type="range" id="input_a" value="0.366025" min="0" max="1" step="0.01" onchange="draw()">
 Rotate:<input type="range" id="input_rot" value="0" min="0" max="1" step="0.01" onchange="draw()">
</dd>
<p/>
<button onclick="tile(0.366025)">(1,√3)</button>
<button onclick="tile(0.5)">(1,1)</button>
<button onclick="tile(0.633975)">(√3,1)</button>
<button onclick="download()">SVG download</button>
<a style="display:none;" id="a_download" download="download"></a>
<p/>
<canvas id="canvas_draw" width="600" height="500" style="border:solid 1px #404040;"></canvas>
</div>
<script>
let scope;
let last_rot=0;
const OFFSET_X = 120;
const OFFSET_Y = 100;
const SCALE = 140;
function setup() {
  bodyMovePrevent();
  paper.setup(canvas_draw);
  paper.view.zoom = SCALE;
  paper.view.center =(new paper.Point(OFFSET_X/SCALE,OFFSET_Y/SCALE));
  draw();
  let tool = new paper.Tool();
  tool.onMouseDrag = (e)=> {
    draw();
  }
  paper.view.draw();
}
function draw(){
  paper.project.clear();
  let val = parseFloat(input_a.value);
  let a = val;
  let b = 1-val;
  let shape = genShape(a,b);
  let dd = new paper.Path();;
  shape.map(sh=>{
    sh[1] += parseFloat(b);
    dd.add(new paper.Point(sh[1],sh[0]));
  });
  dd.closed = true;
  dd.strokeWidth = 0.01;
  dd.strokeColor = 'black';
  dd.fillColor = 'black';
  setCircle(dd.segments[2].point,'red');
  setCircle(dd.segments[7].point,'green');
  setCircle(dd.segments[11].point,'blue');
  setRotation(dd);
}
function setRotation (dd) {
  let rot = 360*parseFloat(input_rot.value);
  let diff = rot-last_rot;
  let avg = new paper.Point( 
    (dd.segments[2].point.x+dd.segments[7].point.x+dd.segments[11].point.x)/3,
    (dd.segments[2].point.y+dd.segments[7].point.y+dd.segments[11].point.y)/3,
  );
  paper.view.rotate(diff,avg);
  last_rot = rot;
}
function setCircle(yx,fill) {
  let circle = new paper.Shape.Circle(yx,0.03);
  if (fill) {
    circle.fillColor =fill;
  }
}
function tile(val) {
  input_a.value = val;
  input_a.dispatchEvent(new Event('change'));
}
function download() {
  const WIDTH = paper.project.view.viewSize.width;
  const HEIGHT = paper.project.view.viewSize.height;
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 500">
${paper.project.exportSVG().innerHTML}
</svg>`;
  a_download.href = 'data:image/svg+xml,'+encodeURIComponent(svg);
  a_download.click();
}
function bodyMovePrevent() {
  document.addEventListener('touchmove', e => e.preventDefault(), {
    passive: false
  });
  document.addEventListener('mousewheel', e => e.preventDefault(), {
    passive: false
  });
}
function genShape( a, b ) {
  const hr3 = 0.5*Math.sqrt(3.0);
  const base_shape = [
    [0,0], [0,-hr3], [0.5,-hr3], [0.75, -0.5*hr3], [1.5, -hr3],
    [2.25, -0.5*hr3], [2, 0], [2.25, 0.5*hr3], [1.5, hr3], [1.5, 2*hr3],
    [1, 2*hr3], [0.5, hr3], [0.75, 0.5*hr3]
  ];
  const sc1 = a / 0.5;
  const sc2 = b / hr3;
  let ret = [[0,0]];
  for (j=0;j< base_shape.length-1; j++ ) {
    let i = j+1;
    let d = dist( base_shape[i-1], base_shape[i] )
    let sc = sc1;
    if (Math.abs(d-hr3) < 1e-5) {
      sc = sc2;
    }
    let v = [base_shape[i][0]-base_shape[i-1][0],
            base_shape[i][1]-base_shape[i-1][1]]
    p = ret[ret.length-1];
    ret.push( [ p[0]+sc*v[0], p[1]+sc*v[1] ] );
  }
  return ret
}
function dist( p, q ) {
  return Math.sqrt( Math.pow((p[0]-q[0]),2) + Math.pow((p[1]-q[1]),2) );
}
</script>
</body>
</html>
